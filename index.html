<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Mini scène 3D — Caméras sphère (Three.js)</title>
		<style>
			html,
			body {
				margin: 0;
				height: 100%;
				background: #0a0b10;
				color: #e6e6e6;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
					Cantarell, "Helvetica Neue", Arial, "Noto Sans",
					"Apple Color Emoji", "Segoe UI Emoji";
			}
			#ui {
				position: fixed;
				top: 12px;
				left: 12px;
				display: flex;
				gap: 8px;
				flex-wrap: wrap;
				z-index: 10;
			}
			.btn {
				padding: 8px 12px;
				border-radius: 12px;
				border: 1px solid #3b3f5c;
				background: #151827;
				color: #e6e6e6;
				cursor: pointer;
				box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
				user-select: none;
			}
			.btn.active {
				background: #2a6df6;
				border-color: #2a6df6;
				color: white;
			}
			#help {
				position: fixed;
				right: 12px;
				top: 12px;
				background: #111525;
				padding: 10px 12px;
				border-radius: 12px;
				border: 1px solid #30344a;
				max-width: 360px;
				line-height: 1.35;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
			}
			#modeLabel {
				font-weight: 700;
			}
			canvas {
				display: block;
			}
			#diag {
				position: fixed;
				left: 12px;
				bottom: 12px;
				background: #101427;
				border: 1px solid #30344a;
				border-radius: 12px;
				padding: 8px 10px;
				font-size: 12px;
				line-height: 1.3;
				box-shadow: 0 2px 10px rgba(0, 0, 0, 0.35);
				max-width: 520px;
			}
			#tests {
				margin-top: 6px;
			}
			.pass {
				color: #7cff9b;
			}
			.fail {
				color: #ff7c7c;
			}
			.muted {
				color: #9aa4d3;
			}
		</style>
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
				}
			}
		</script>
	</head>
	<body>
		<div id="ui">
			<button class="btn" data-mode="TPS">3e personne</button>
			<button
				alt="on voit le personnage de l'interieur !! (HS)"
				title="on voit le personnage de l'interieur !! (HS)"
				class="btn"
				data-mode="FPS"
				>1re personne</button
			>
			<button class="btn" data-mode="SAT">Satellite</button>
			<button class="btn" data-mode="TOP">Top‑down</button>
			<button
				title="ça fait n'importe quoi ! (HS)"
				alt="ça fait n'importe quoi ! (HS)"
				class="btn"
				data-mode="ORBIT"
				>Orbit perso</button
			>
			<button class="btn" data-mode="ORBIT_SPHERE">Orbit sphère</button>
			<button class="btn" id="runTests">Tests</button>
		</div>
		<div id="help"> </div>
		<div id="diag" class="muted">
			<div
				><span id="modeLabel">Mode:</span>
				<span id="modeName">3e personne</span></div
			>
			<ul style="margin: 8px 0 0 18px; padding: 0">
				<li>Z / S : avancer / reculer</li>
				<li>Q / D : pivoter gauche / droite</li>
				<li>Chiffres 1..6 : changer de caméra</li>
				<li
					>Orbit perso : souris pour orbiter / zoom (autour du
					personnage)</li
				>
				<li
					>Orbit sphère : souris pour orbiter / zoom (autour du centre de
					la sphère)</li
				>
				<li>Satellite : molette = zoom</li>
				<li>Satellite : + / − = zoom +/- (clavier)</li>
				<li>Top‑down : molette = zoom</li>
				<li>Top‑down : + / − = zoom +/- (clavier)</li>
			</ul>
			<div id="tests"></div>
		</div>

		<script type="module">
			import * as THREE from "three";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			// --- Textures Mars (optionnelles) ---
			const loader = new THREE.TextureLoader();
			const color = loader.load("textures/mars/mars_8k_color.jpg");
			const bump = loader.load("textures/mars/mars_8k_bump.jpg");
			const normal = loader.load("textures/mars/mars_1k_normal.jpg");

			// --- Config (placeholder pour futurs assets) ---
			const config = {
				player: { glb: "assets/Animated_Base_Character.glb" },
			};

			// --- Renderer / Scene / Camera ---
			const renderer = new THREE.WebGLRenderer({ antialias: true });
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
			document.body.appendChild(renderer.domElement);

			const scene = new THREE.Scene();
			scene.background = new THREE.Color(0x070910);

			const camera = new THREE.PerspectiveCamera(
				60,
				window.innerWidth / window.innerHeight,
				0.05,
				20000
			);
			camera.position.set(0, 6, 10);

			const controls = new OrbitControls(camera, renderer.domElement);
			controls.enabled = false;
			controls.enableDamping = true;
			controls.enablePan = false; // évite le pan involontaire au bouton droit
			controls.enableZoom = true;
			controls.minDistance = 0.5;
			controls.maxDistance = 5000;
			controls.target.set(0, 0, 0);

			scene.add(new THREE.AmbientLight(0xffffff, 0.45));
			const dir = new THREE.DirectionalLight(0xffffff, 0.9);
			dir.position.set(8, 10, 6);
			scene.add(dir);

			// --- Planète ---
			const R = 50;
			const marsMaterial = new THREE.MeshStandardMaterial({
				map: color,
				bumpMap: bump,
				bumpScale: 0.1,
				normalMap: normal,
				normalScale: new THREE.Vector2(1, 1),
				roughness: 1,
			});
			const marsGeometry = new THREE.SphereGeometry(R, 64, 64);
			const planet = new THREE.Mesh(marsGeometry, marsMaterial);
			scene.add(planet);

			const atmosphere = new THREE.Mesh(
				new THREE.SphereGeometry(R * 1.03, 64, 48),
				new THREE.MeshBasicMaterial({
					color: 0x992205,
					transparent: true,
					opacity: 0.07,
				})
			);
			scene.add(atmosphere);

			// --- Repères visuels surface ---
			const cubeMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
			const cubeGeo = new THREE.BoxGeometry(0.2, 0.2, 0.2);
			for (let i = 0; i < 40; i++) {
				const phi = Math.acos(2 * Math.random() - 1);
				const theta = Math.random() * Math.PI * 2;
				const x = R * Math.sin(phi) * Math.cos(theta);
				const y = R * Math.cos(phi);
				const z = R * Math.sin(phi) * Math.sin(theta);
				const cube = new THREE.Mesh(cubeGeo, cubeMat);
				cube.position.set(x, y, z);
				cube.lookAt(0, 0, 0);
				scene.add(cube);
			}

			// Poteaux blancs
			const poleMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
			const poleGeo = new THREE.CylinderGeometry(0.15, 0.15, 20, 16);
			const northPole = new THREE.Mesh(poleGeo, poleMat);
			northPole.position.set(0, R + 1, 0);
			scene.add(northPole);
			const southPole = new THREE.Mesh(poleGeo, poleMat);
			southPole.position.set(0, -R - 1, 0);
			scene.add(southPole);

			// Étoiles
			const stars = new THREE.Points(
				new THREE.BufferGeometry(),
				new THREE.PointsMaterial({ size: 0.03, color: 0xffffff })
			);
			const starPos = new Float32Array(2000 * 3);
			for (let i = 0; i < 2000; i++) {
				const r = 120 + Math.random() * 80;
				const phi = Math.acos(2 * Math.random() - 1);
				const theta = Math.random() * Math.PI * 2;
				starPos[i * 3] = r * Math.sin(phi) * Math.cos(theta);
				starPos[i * 3 + 1] = r * Math.cos(phi);
				starPos[i * 3 + 2] = r * Math.sin(phi) * Math.sin(theta);
			}
			stars.geometry.setAttribute(
				"position",
				new THREE.BufferAttribute(starPos, 3)
			);
			scene.add(stars);

			// --- Personnage simple (boule + yeux) ---
			const charGroup = new THREE.Group();
			charGroup.add(
				new THREE.Mesh(
					new THREE.SphereGeometry(0.2, 16, 12),
					new THREE.MeshStandardMaterial({ color: 0xffcc66 })
				)
			);
			const eyes = new THREE.Group();
			const eye_gauche = new THREE.Group();
			const eye_droit = new THREE.Group();
			const eye_g = new THREE.Mesh(
				new THREE.SphereGeometry(0.04, 16, 12),
				new THREE.MeshStandardMaterial({ color: 0xffffff })
			);
			const eye_d = new THREE.Mesh(
				new THREE.SphereGeometry(0.04, 16, 12),
				new THREE.MeshStandardMaterial({ color: 0xffffff })
			);
			const eye_g_pupille = new THREE.Mesh(
				new THREE.SphereGeometry(0.03, 16, 12),
				new THREE.MeshStandardMaterial({ color: 0x000000 })
			);
			const eye_d_pupille = new THREE.Mesh(
				new THREE.SphereGeometry(0.03, 16, 12),
				new THREE.MeshStandardMaterial({ color: 0x000000 })
			);
			eye_gauche.add(eye_g);
			eye_droit.add(eye_d);
			eyes.add(eye_gauche);
			eyes.add(eye_droit);
			charGroup.add(eyes);
			scene.add(charGroup);
			eye_gauche.position.set(0.05, 0.15, 0.1);
			eye_droit.position.set(-0.05, 0.15, 0.1);
			eye_g_pupille.position.z = 0.02;
			eye_d_pupille.position.z = 0.02;
			eye_gauche.add(eye_g_pupille);
			eye_droit.add(eye_d_pupille);

			// --- Déplacement sur sphère ---
			let charPos = new THREE.Vector3(R, 0, 0);
			let charForward = new THREE.Vector3();
			const speed = 0.018,
				rotSpeed = 0.035;
			function initForwardAt(pos) {
				const n = pos.clone().normalize();
				charForward
					.set(0, 0, 1)
					.addScaledVector(n, -n.dot(new THREE.Vector3(0, 0, 1)));
				if (charForward.lengthSq() < 1e-8)
					charForward
						.set(1, 0, 0)
						.addScaledVector(n, -n.dot(new THREE.Vector3(1, 0, 0)));
				charForward.normalize();
			}
			initForwardAt(charPos);

			const keys = new Set();
			window.addEventListener("keydown", (e) => {
				keys.add(e.key.toLowerCase());
			});
			window.addEventListener("keyup", (e) => {
				keys.delete(e.key.toLowerCase());
			});

			const MODES = {
				TPS: "TPS",
				FPS: "FPS",
				SAT: "SAT",
				TOP: "TOP",
				ORBIT: "ORBIT",
				ORBIT_SPHERE: "ORBIT_SPHERE",
			};
			let mode = MODES.TPS;
			let topDownHeight = 3.2;
			const TOP_MIN = 1.2,
				TOP_MAX = 10;
			// Satellite : distance caméra variable
			let satDistance = R * 3.2;
			const SAT_MIN = R * 1.2,
				SAT_MAX = R * 10;

			const modeName = document.getElementById("modeName");
			const buttons = [...document.querySelectorAll(".btn")];
			document.getElementById("ui").addEventListener("click", (e) => {
				if (e.target.matches("button[data-mode]"))
					setMode(e.target.dataset.mode);
			});

			function setMode(m) {
				mode = m;
				buttons.forEach((b) =>
					b.classList.toggle("active", b.dataset.mode === m)
				);
				const labels = {
					TPS: "3e personne",
					FPS: "1re personne",
					SAT: "Satellite",
					TOP: "Top‑down",
					ORBIT: "Orbit perso",
					ORBIT_SPHERE: "Orbit sphère",
				};
				modeName.textContent = labels[m] || m;
				controls.enabled =
					mode === MODES.ORBIT || mode === MODES.ORBIT_SPHERE;
				if (mode === MODES.ORBIT) {
					controls.enablePan = false;
					controls.minDistance = 0.8;
					controls.maxDistance = 8;
					controls.target.copy(charPos);
					const { n } = tangentBasisAt(charPos);
					const back = charForward
						.clone()
						.multiplyScalar(-2.5)
						.addScaledVector(n, 1.0);
					camera.position.copy(charPos).add(back);
					camera.lookAt(charPos);
				} else if (mode === MODES.ORBIT_SPHERE) {
					controls.enablePan = false;
					controls.minDistance = R * 1.1;
					controls.maxDistance = R * 5.0;
					controls.target.set(0, 0, 0);
					let d = camera.position.length();
					if (
						!Number.isFinite(d) ||
						d < controls.minDistance ||
						d > controls.maxDistance
					) {
						const dir = camera.position.clone().normalize();
						if (dir.lengthSq() < 1e-6) dir.set(1, 0, 0);
						const desired = THREE.MathUtils.clamp(
							R * 2.0,
							controls.minDistance * 1.05,
							controls.maxDistance * 0.95
						);
						camera.position.copy(dir.multiplyScalar(desired));
						camera.lookAt(0, 0, 0);
					}
				} else {
					controls.enabled = false;
				}
			}
			setMode(MODES.TPS);

			function tangentBasisAt(pos) {
				const n = pos.clone().normalize();
				let ref = new THREE.Vector3(0, 1, 0);
				if (Math.abs(n.dot(ref)) > 0.95) ref = new THREE.Vector3(1, 0, 0);
				const t1 = new THREE.Vector3().crossVectors(ref, n).normalize();
				const t2 = new THREE.Vector3().crossVectors(n, t1).normalize();
				return { n, t1, t2 };
			}

			function updateCharacter() {
				const n0 = charPos.clone().normalize();
				if (keys.has("q")) charForward.applyAxisAngle(n0, +rotSpeed);
				if (keys.has("d")) charForward.applyAxisAngle(n0, -rotSpeed);
				if (keys.has("z")) charPos.addScaledVector(charForward, speed);
				if (keys.has("s")) charPos.addScaledVector(charForward, -speed);
				charPos.normalize().multiplyScalar(R);
				const n1 = charPos.clone().normalize();
				const q = new THREE.Quaternion().setFromUnitVectors(n0, n1);
				charForward.applyQuaternion(q);
				charForward.addScaledVector(n1, -charForward.dot(n1)).normalize();
				const lookAt = charPos.clone().add(charForward);
				charGroup.position.copy(charPos);
				charGroup.up.copy(n1);
				charGroup.lookAt(lookAt);
			}

			function updateCamera() {
				const { n } = tangentBasisAt(charPos);
				const forward = charForward;
				if (mode === MODES.TPS) {
					const camPos = charPos
						.clone()
						.addScaledVector(forward, -1.6)
						.addScaledVector(n, 0.7);
					camera.position.lerp(camPos, 0.25);
					camera.up.copy(n);
					camera.lookAt(charPos.clone().addScaledVector(forward, 1.2));
				} else if (mode === MODES.FPS) {
					const eye = charPos.clone().addScaledVector(n, 0.18);
					const target = charPos.clone().addScaledVector(forward, 2.0);
					camera.position.lerp(eye, 0.4);
					camera.up.copy(n);
					camera.lookAt(target);
				} else if (mode === MODES.SAT) {
					const camPos = charPos
						.clone()
						.normalize()
						.multiplyScalar(satDistance);
					camera.position.lerp(camPos, 0.2);
					camera.up.set(0, 1, 0);
					camera.lookAt(charPos);
				} else if (mode === MODES.TOP) {
					const camPos = charPos.clone().addScaledVector(n, topDownHeight);
					camera.position.lerp(camPos, 0.25);
					camera.up.copy(forward);
					camera.lookAt(charPos);
				} else if (mode === MODES.ORBIT) {
					controls.target.copy(charPos);
					controls.update();
				} else if (mode === MODES.ORBIT_SPHERE) {
					controls.target.set(0, 0, 0);
					controls.update();
				}
			}

			function tick() {
				updateCharacter();
				updateCamera();
				renderer.render(scene, camera);
				requestAnimationFrame(tick);
			}
			tick();

			window.addEventListener("resize", () => {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
				renderer.setSize(window.innerWidth, window.innerHeight);
			});

			// --- Zoom molette : Top-down & Satellite ---
			window.addEventListener(
				"wheel",
				(e) => {
					if (mode !== MODES.TOP && mode !== MODES.SAT) return;
					e.preventDefault();
					const factor = Math.exp(e.deltaY * 0.001);
					if (mode === MODES.TOP) {
						topDownHeight = THREE.MathUtils.clamp(
							topDownHeight * factor,
							TOP_MIN,
							TOP_MAX
						);
					} else if (mode === MODES.SAT) {
						satDistance = THREE.MathUtils.clamp(
							satDistance * factor,
							SAT_MIN,
							SAT_MAX
						);
					}
				},
				{ passive: false }
			);

			// --- Clavier : Top-down & Satellite (+ modes) ---
			window.addEventListener("keydown", (e) => {
				if (mode === MODES.TOP) {
					if (e.key === "+" || e.key === "=")
						topDownHeight = Math.max(TOP_MIN, topDownHeight * 0.9);
					if (e.key === "-")
						topDownHeight = Math.min(TOP_MAX, topDownHeight * 1.1);
				}
				if (mode === MODES.SAT) {
					if (e.key === "+" || e.key === "=")
						satDistance = Math.max(SAT_MIN, satDistance * 0.9);
					if (e.key === "-")
						satDistance = Math.min(SAT_MAX, satDistance * 1.1);
				}
				if (e.key === "1") setMode(MODES.TPS);
				if (e.key === "2") setMode(MODES.FPS);
				if (e.key === "3") setMode(MODES.SAT);
				if (e.key === "4") setMode(MODES.TOP);
				if (e.key === "5") setMode(MODES.ORBIT);
				if (e.key === "6") setMode(MODES.ORBIT_SPHERE);
			});

			// --- Tests ---
			const log = (ok, msg) => {
				console.log((ok ? "✔︎ " : "✖︎ ") + msg);
			};
			function runTests() {
				try {
					log(!!THREE, "THREE chargé via import map");
					log(
						renderer instanceof THREE.WebGLRenderer,
						"Renderer initialisé"
					);
					log(scene instanceof THREE.Scene, "Scene créée");
					log(camera instanceof THREE.PerspectiveCamera, "Camera créée");
					log(
						planet.geometry.parameters.radius === R,
						"Planète rayon R correct"
					);
					// Nouveaux tests
					log(
						typeof satDistance === "number" &&
							satDistance >= R * 1.2 &&
							satDistance <= R * 10,
						"satDistance initial dans les bornes"
					);
					const td0 = topDownHeight;
					const td1 = THREE.MathUtils.clamp(td0 * 0.5, TOP_MIN, TOP_MAX);
					log(td1 >= TOP_MIN && td1 <= TOP_MAX, "Clamp Top-down valide");
					setMode(MODES.ORBIT_SPHERE);
					log(
						controls.enabled && controls.minDistance === R * 1.1,
						"Orbit sphère: contrôles actifs et bornes OK"
					);
					setMode(MODES.ORBIT);
					log(
						controls.enabled && controls.maxDistance === 8,
						"Orbit perso: bornes OK"
					);
				} catch (e) {
					console.log("Tests interrompus: " + (e?.message || e));
				}
			}
			document
				.getElementById("runTests")
				.addEventListener("click", runTests);
		</script>
	</body>
</html>
