<!DOCTYPE html>
<html lang="fr">
	<head>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<title>Inspecteur d’animations GLB</title>
		<style>
			:root {
				--bg: #0f172a;
				--panel: #111827;
				--accent: #22d3ee;
				--muted: #94a3b8;
				--ok: #10b981;
				--warn: #f59e0b;
				--err: #ef4444;
				--ring: #22d3ee33;
			}
			* {
				box-sizing: border-box;
			}
			body {
				margin: 0;
				font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
					Cantarell, Noto Sans, sans-serif;
				background: linear-gradient(180deg, #0b1020, #0f172a);
				color: #e5e7eb;
				min-height: 100vh;
				display: flex;
				flex-direction: column;
			}
			header {
				padding: 18px 22px;
				border-bottom: 1px solid #1f2937;
				background: rgba(17, 24, 39, 0.7);
				backdrop-filter: blur(8px);
				position: sticky;
				top: 0;
			}
			header h1 {
				margin: 0;
				font-size: 18px;
				letter-spacing: 0.2px;
			}
			main {
				width: min(1200px, 94vw);
				margin: 24px auto 48px;
				display: grid;
				grid-template-columns: 1fr;
				gap: 18px;
			}
			.drop {
				border: 2px dashed #334155;
				border-radius: 16px;
				padding: 24px;
				display: flex;
				gap: 16px;
				align-items: center;
				justify-content: center;
				flex-direction: column;
				background: #0b1224;
			}
			.drop.drag {
				border-color: var(--accent);
				box-shadow: 0 0 0 6px var(--ring);
			}
			.drop b {
				font-size: 18px;
			}
			.drop p {
				margin: 0;
				color: var(--muted);
			}
			.btn {
				appearance: none;
				border: 1px solid #334155;
				background: #0b1224;
				color: #e5e7eb;
				padding: 10px 14px;
				border-radius: 12px;
				cursor: pointer;
			}
			.btn:hover {
				border-color: #475569;
			}
			.row {
				display: flex;
				gap: 12px;
				flex-wrap: wrap;
				align-items: center;
			}
			.card {
				border: 1px solid #1f2937;
				background: linear-gradient(180deg, #0b1224, #0b1224 60%, #0a0f1e);
				border-radius: 16px;
				padding: 16px;
			}
			.muted {
				color: var(--muted);
			}
			.grid {
				display: grid;
				grid-template-columns: repeat(12, 1fr);
				gap: 12px;
			}
			.span-4 {
				grid-column: span 4;
			}
			.span-8 {
				grid-column: span 8;
			}
			.span-12 {
				grid-column: span 12;
			}
			@media (max-width: 900px) {
				.grid {
					grid-template-columns: 1fr;
				}
				.span-4,
				.span-8,
				.span-12 {
					grid-column: 1;
				}
			}
			.tbl {
				width: 100%;
				border-collapse: collapse;
				margin-top: 6px;
			}
			.tbl th,
			.tbl td {
				border-bottom: 1px solid #1f2937;
				padding: 8px 6px;
				text-align: left;
				font-size: 14px;
			}
			.pill {
				font-size: 12px;
				border: 1px solid #334155;
				border-radius: 999px;
				padding: 2px 8px;
				color: #cbd5e1;
			}
			#viewer {
				height: 520px;
				border-radius: 16px;
				overflow: hidden;
				position: relative;
			}
			#viewer canvas {
				display: block;
				width: 100%;
				height: 100%;
			}
			.hint {
				font-size: 12px;
				color: #94a3b8;
			}
			/* Accordions */
			.accordion {
				border: 1px solid #1f2937;
				border-radius: 14px;
				background: #0b1224;
				overflow: hidden;
				margin-bottom: 10px;
			}
			.accordion[open] {
				box-shadow: 0 0 0 4px var(--ring);
			}
			.accordion summary {
				list-style: none;
				cursor: pointer;
				display: flex;
				align-items: center;
				justify-content: space-between;
				gap: 12px;
				padding: 12px 14px;
			}
			.accordion summary::-webkit-details-marker {
				display: none;
			}
			.acc-title {
				margin: 0;
				font-size: 16px;
			}
			.acc-meta {
				color: var(--muted);
				font-size: 13px;
			}
			.acc-body {
				padding: 0 14px 12px;
			}
			.chev {
				transition: transform 0.2s ease;
			}
			.accordion[open] .chev {
				transform: rotate(90deg);
			}
		</style>

		<!-- Import map pour résoudre le spécificateur "three" et ses addons. -->
		<script type="importmap">
			{
				"imports": {
					"three": "https://unpkg.com/three@0.160.0/build/three.module.js",
					"three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
				}
			}
		</script>
	</head>
	<body>
		<header>
			<h1
				>Inspecteur d’animations GLB · glissez votre fichier pour lister les
				clips</h1
			>
		</header>
		<main>
			<section class="drop card" id="drop">
				<b>Glissez un fichier <code>.glb</code> ici</b>
				<p>ou <button class="btn" id="pick">choisir un fichier</button></p>
				<p class="muted"
					>astuce : les <code>.gltf</code> avec ressources externes ne sont
					pas supportés en drop pur. Préférez un
					<code>.glb</code> (binaire) ou un <code>.gltf</code> totalement
					embarqué.</p
				>
				<input
					id="file"
					type="file"
					accept=".glb,.gltf,model/gltf-binary,model/gltf+json"
					hidden />
			</section>

			<section class="grid">
				<div class="span-12 card">
					<h3 style="margin-top: 0">Aperçu 3D</h3>
					<div id="viewer"></div>
				</div>
				<div class="span-4 card">
					<h3 style="margin-top: 0">Fichier</h3>
					<div id="fileMeta" class="muted">Aucun fichier chargé.</div>
					<div id="prefixMeta" class="muted">Préfixe : —</div>
					<div class="row" style="margin-top: 10px">
						<button
							class="btn"
							id="copyJson"
							title="Copier les infos en JSON"
							disabled
							>Copier JSON</button
						>
						<button
							class="btn"
							id="downloadJson"
							title="Télécharger le JSON"
							disabled
							>Télécharger JSON</button
						>
						<span id="status" class="pill">en attente</span>
					</div>
					<p class="hint"
						>Après chargement : lecture auto de l’animation
						<code>Idle</code> si trouvée.</p
					>
				</div>
				<div class="span-8 card">
					<h3 style="margin-top: 0">Animations détectées</h3>
					<div id="animSummary" class="muted">—</div>
					<div id="animList"></div>
				</div>
			</section>

			<details class="card">
				<summary><strong>Comment ça marche ?</strong></summary>
				<p
					>Cette page charge votre fichier localement dans le navigateur,
					puis utilise <code>GLTFLoader</code> (Three.js) pour lire la
					liste des <em>AnimationClips</em>. L’aperçu 3D affiche le modèle
					et joue automatiquement l’animation <code>Idle</code> si elle
					existe (recherche insensible à la casse).</p
				>
				<ul>
					<li
						>Support recommandé : <code>.glb</code> (binaire). Les
						<code>.gltf</code> <em>peuvent</em> fonctionner s’ils sont
						entièrement embarqués.</li
					>
					<li
						>Compression Draco : partiellement prise en charge via
						<code>DRACOLoader</code> (nécessite Internet pour télécharger
						le décodeur).</li
					>
					<li
						>Résultat : nom du clip, durée (s), nombre de pistes, détail
						des pistes (nom, clés). Téléchargeable en JSON.</li
					>
				</ul>
			</details>
		</main>

		<script type="module">
			import * as THREE from "three";
			import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
			import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
			import { OrbitControls } from "three/addons/controls/OrbitControls.js";

			const drop = document.getElementById("drop");
			const pick = document.getElementById("pick");
			const fileInput = document.getElementById("file");
			const fileMeta = document.getElementById("fileMeta");
			const prefixMeta = document.getElementById("prefixMeta");
			const animList = document.getElementById("animList");
			const animSummary = document.getElementById("animSummary");
			const status = document.getElementById("status");
			const copyBtn = document.getElementById("copyJson");
			const dlBtn = document.getElementById("downloadJson");
			const viewer = document.getElementById("viewer");

			let lastReport = null;
			if (prefixMeta) prefixMeta.textContent = "Préfixe : —";
			let renderer,
				scene,
				camera,
				controls,
				mixer,
				clock = new THREE.Clock();
			let currentRoot = null;
			let rafId = 0;
			let currentFileName = "";

			const loader = new GLTFLoader();
			const draco = new DRACOLoader();
			draco.setDecoderPath("https://www.gstatic.com/draco/v1/decoders/");
			loader.setDRACOLoader(draco);

			pick.addEventListener("click", () => fileInput.click());
			fileInput.addEventListener("change", (e) => {
				const f = e.target.files[0];
				if (f) handleFile(f);
			});

			["dragenter", "dragover"].forEach((evt) =>
				drop.addEventListener(evt, (e) => {
					e.preventDefault();
					e.stopPropagation();
					drop.classList.add("drag");
				})
			);
			["dragleave", "drop"].forEach((evt) =>
				drop.addEventListener(evt, (e) => {
					e.preventDefault();
					e.stopPropagation();
					drop.classList.remove("drag");
				})
			);
			drop.addEventListener("drop", (e) => {
				const f = e.dataTransfer.files && e.dataTransfer.files[0];
				if (f) handleFile(f);
			});

			dlBtn.addEventListener("click", () => {
				if (!lastReport) return;
				const json = JSON.stringify(lastReport, null, 2);
				const blob = new Blob([json], { type: "application/json" });
				const a = document.createElement("a");
				a.href = URL.createObjectURL(blob);
				const base = baseName(currentFileName || "animations");
				a.download = `${base}.json`;
				document.body.appendChild(a);
				a.click();
				setTimeout(() => {
					URL.revokeObjectURL(a.href);
					a.remove();
				}, 0);
			});

			async function handleFile(file) {
				resetUI();
				currentFileName = file.name;
				fileMeta.innerHTML = `<div><b>${escapeHtml(
					file.name
				)}</b></div><div class="muted">${(file.size / 1024 / 1024).toFixed(
					2
				)} Mo · ${file.type || "type inconnu"}</div>`;
				status.textContent = "chargement…";
				try {
					const buf = await file.arrayBuffer();
					await parseGLTF(buf, file.name);
				} catch (err) {
					console.error(err);
					status.textContent = "erreur";
					status.classList.add("err");
					animSummary.textContent =
						"Impossible de lire ce fichier. Assurez-vous qu'il s'agit d'un .glb valide.";
				}
			}

			function parseGLTF(arrayBuffer, name) {
				return new Promise((resolve, reject) => {
					loader.parse(
						arrayBuffer,
						"",
						(gltf) => {
							const clips = gltf.animations || [];
							status.textContent = "analysé";
							status.classList.add("ok");

							// UI de liste
							const sorted = sortClips(clips);
							renderClips(sorted, name);

							// Scène 3D
							setupViewer();
							showModel(gltf, clips);

							resolve();
						},
						(err) => reject(err)
					);
				});
			}

			function sortClips(clips) {
				return [...clips].sort((a, b) => {
					const an = (a.name || "").toLowerCase();
					const bn = (b.name || "").toLowerCase();
					if (an && bn) {
						return an.localeCompare(bn);
					}
					if (an && !bn) return -1;
					if (!an && bn) return 1;
					return b.duration - a.duration;
				});
			}

			function renderClips(clips, fileName) {
				animSummary.innerHTML = `<b>${clips.length}</b> animation${
					clips.length > 1 ? "s" : ""
				} détectée${clips.length > 1 ? "s" : ""}.`;
				const container = document.createElement("div");
				const prefix = detectPrefix(clips);
				const report = { file: fileName, prefix: prefix, animations: [] };
				if (prefixMeta)
					prefixMeta.textContent = `Préfixe : ${prefix || "(aucun)"}`;

				clips.forEach((clip, idx) => {
					const tracks = clip.tracks || [];
					const clipName =
						clip.name && clip.name.length
							? clip.name
							: `Clip #${idx + 1}`;
					const dur = Number.isFinite(clip.duration) ? clip.duration : 0;

					// —— Accordéon ——
					const details = document.createElement("details");
					details.className = "accordion";
					const summary = document.createElement("summary");
					summary.innerHTML = `
          <h4 class="acc-title">${escapeHtml(clipName)}</h4>
          <div class="acc-meta">Durée : <b>${dur.toFixed(
					3
				)}</b> s · Pistes : <b>${
						tracks.length
					}</b> <span class="chev">▸</span></div>
        `;
					const body = document.createElement("div");
					body.className = "acc-body";
					body.innerHTML = `
          <table class="tbl">
            <thead><tr><th>#</th><th>Piste</th><th>Clés</th></tr></thead>
            <tbody>${tracks
					.map(
						(t, i) =>
							`<tr><td>${i + 1}</td><td><code>${escapeHtml(
								t.name || "(sans nom)"
							)}</code></td><td>${
								t.times ? t.times.length : "—"
							}</td></tr>`
					)
					.join("")}</tbody>
          </table>`;
					details.appendChild(summary);
					details.appendChild(body);
					container.appendChild(details);

					report.animations.push({
						name: clipName,
						duration: +dur.toFixed(6),
						tracks: tracks.map((t) => ({
							name: t.name || "",
							keys: t.times ? t.times.length : 0,
						})),
					});
				});

				animList.innerHTML = "";
				animList.appendChild(container);
				lastReport = report;
				copyBtn.disabled = false;
				dlBtn.disabled = false;
			}

			function setupViewer() {
				// Dispose précédent
				cancelAnimationFrame(rafId);
				if (renderer) {
					renderer.dispose();
					viewer.innerHTML = "";
				}
				if (scene) {
					disposeScene(scene);
				}
				mixer = null;
				currentRoot = null;

				const w =
					viewer.clientWidth ||
					viewer.getBoundingClientRect().width ||
					800;
				const h = 520;

				renderer = new THREE.WebGLRenderer({
					antialias: true,
					alpha: true,
				});
				renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
				renderer.setSize(w, h);
				viewer.appendChild(renderer.domElement);

				scene = new THREE.Scene();
				scene.background = new THREE.Color(0x0b1020);

				camera = new THREE.PerspectiveCamera(50, w / h, 0.1, 1000);
				camera.position.set(3, 2, 4);

				controls = new OrbitControls(camera, renderer.domElement);
				controls.enableDamping = true;

				// Éclairage
				const hemi = new THREE.HemisphereLight(0xffffff, 0x334155, 0.8);
				scene.add(hemi);
				const dir = new THREE.DirectionalLight(0xffffff, 1.0);
				dir.position.set(5, 10, 7);
				dir.castShadow = false;
				scene.add(dir);

				// Sol léger (grid helper)
				const grid = new THREE.GridHelper(10, 20, 0x334155, 0x1f2937);
				grid.material.opacity = 0.25;
				grid.material.transparent = true;
				scene.add(grid);

				window.addEventListener("resize", onResize);
				animate();
			}

			function showModel(gltf, clips) {
				// ajouter le modèle
				currentRoot = gltf.scene || gltf.scenes?.[0];
				if (currentRoot) {
					scene.add(currentRoot);
					frameToFit(currentRoot, camera, controls);
				}

				// mixer & lecture Idle si trouvée (sinon 1er clip en fallback)
				if (clips && clips.length) {
					mixer = new THREE.AnimationMixer(currentRoot || scene);
					const clipToPlay = findIdle(clips) || clips[0];
					if (clipToPlay) {
						const action = mixer.clipAction(clipToPlay);
						action.reset();
						action.play();
						status.textContent = `lecture : ${
							clipToPlay.name || "Clip #1"
						}`;
					}
					status.classList.add("ok");
				} else {
					status.textContent = "aucune animation trouvée";
				}
			}

			function findIdle(clips) {
				return (
					clips.find((c) =>
						/(^|[^a-z])idle([^a-z]|$)/i.test(c.name || "")
					) || null
				);
			}

			function frameToFit(object3D, cam, ctrls) {
				const box = new THREE.Box3().setFromObject(object3D);
				const size = new THREE.Vector3();
				const center = new THREE.Vector3();
				box.getSize(size);
				box.getCenter(center);
				const maxDim = Math.max(size.x, size.y, size.z) || 1;
				const fov = cam.fov * (Math.PI / 180);
				let dist = maxDim / 2 / Math.tan(fov / 2);
				dist *= 1.4; // marge
				cam.position
					.copy(center)
					.add(new THREE.Vector3(dist, dist * 0.6, dist));
				cam.near = Math.max(0.01, dist / 100);
				cam.far = Math.max(1000, dist * 10);
				cam.updateProjectionMatrix();
				cam.lookAt(center);
				ctrls.target.copy(center);
				ctrls.update();
			}

			function onResize() {
				if (!renderer || !camera) return;
				const w =
					viewer.clientWidth ||
					viewer.getBoundingClientRect().width ||
					800;
				const h = 520;
				renderer.setSize(w, h);
				camera.aspect = w / h;
				camera.updateProjectionMatrix();
			}

			function animate() {
				const dt = clock.getDelta();
				if (mixer) mixer.update(dt);
				controls && controls.update();
				renderer && renderer.render(scene, camera);
				rafId = requestAnimationFrame(animate);
			}

			function disposeScene(root) {
				root.traverse((o) => {
					if (o.isMesh) {
						o.geometry && o.geometry.dispose();
						if (o.material) {
							if (Array.isArray(o.material))
								o.material.forEach((m) => m.dispose && m.dispose());
							else o.material.dispose && o.material.dispose();
						}
					}
				});
			}

			function resetUI() {
				animList.innerHTML = "";
				animSummary.textContent = "—";
				status.textContent = "lecture…";
				status.classList.remove("ok", "warn", "err");
				copyBtn.disabled = true;
				dlBtn.disabled = true;
				lastReport = null;
			}

			function baseName(filename) {
				return (
					String(filename || "").replace(/\.[^.]+$/, "") || "animations"
				);
			}

			copyBtn.addEventListener("click", async () => {
				if (!lastReport) return;
				try {
					await navigator.clipboard.writeText(
						JSON.stringify(lastReport, null, 2)
					);
					flash(copyBtn, "Copié !");
				} catch {
					alert("Impossible de copier dans le presse-papier.");
				}
			});

			function detectPrefix(clips) {
				if (!clips || !clips.length) return "";
				const names = clips
					.map((c) => c.name || "")
					.filter((n) => n.length > 0);
				if (names.length === 0) return "";
				// Longest Common Prefix sur tous les noms (préserve les séparateurs comme '_' ou '|').
				let lcp = names[0];
				for (let i = 1; i < names.length; i++) {
					const s = names[i];
					let j = 0;
					const max = Math.min(lcp.length, s.length);
					while (j < max && lcp.charCodeAt(j) === s.charCodeAt(j)) j++;
					lcp = lcp.slice(0, j);
					if (lcp === "") return "";
				}
				return lcp; // renvoie le préfixe tel quel, y compris '_' ou '|' s'ils en font partie
			}

			function escapeHtml(str) {
				return String(str).replace(
					/[&<>"']/g,
					(s) =>
						({
							"&": "&amp;",
							"<": "&lt;",
							">": "&gt;",
							'"': "&quot;",
							"'": "&#39;",
						}[s])
				);
			}
			function flash(btn, text) {
				const prev = btn.textContent;
				btn.textContent = text;
				btn.disabled = true;
				setTimeout(() => {
					btn.textContent = prev;
					btn.disabled = false;
				}, 900);
			}
		</script>
	</body>
</html>
